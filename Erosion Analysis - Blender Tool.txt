# EROSION ANALYSYS - BLENDER TOOL
# Calculate the amount of erosion of a 3D model from its ideal original geometry.
#
# Calculate the thickness of the separation between each face of a mesh ("original" surface) and a second mesh ("eroded" surface).
# The "eroded" object is usually the digital 3D model of a building, generated with photogrammetry or lidar.
# The "original" surface is usually an object generated by the user, and represents the expected original surface of the building before being eroded.
# The "original" surface must be subdivided into a large number of tiles, small enough to act as the pixels of an image.
# In this way, after running the script, the "original" surface can be colored like an image, to represent the erosion distribution.  

# Only faces with Z within Zmin-Zmax and with erosion within erosion_max, are processed.
# The erosion value is stored as a gray color in a new Color Attribute ("Erosion"), that can be used to colorcode the object surface based on the amount of erosion.
# A transparent color is assigned to the faces where an erosion value is not calculated.
# Face area, erosion and volume (area * erosion) are exported to a text file (.csv).
# The format of the output text file is: face index, x, y, z (coordinates of the face center), cell area, erosion, volume.
# The file can be opened in Excel for further analysis, i.e. calculate the total volume of erosion.

# Inspired by:
# https://blender.stackexchange.com/questions/91626/calculate-surfaces-thickness

# Procedure to run the script:
#  update the "original_obj" and "eroded_obj" names
#  set erosion_max, Zmin and Zmax (only cells within these values will be avaluated)
#  set outfile (the output text file name .csv)
#  run the script

import bpy

#Update these parameters =============================================================================
original_obj = bpy.context.scene.objects["Original surface"]
eroded_obj = bpy.context.scene.objects["Eroded surface"]
erosion_max = 0.14
Zmin = 0
Zmax = 3.2
outfile = "C:\\Users\\ricca\\Documents\\_Congress-Talks\\_2024-10 Geoheritage\\erosion.csv"
#=====================================================================================================

# preliminary setups
original_mw = original_obj.matrix_world
eroded_mw = eroded_obj.matrix_world
eroded_mwi = eroded_mw.inverted()
matrice = eroded_mwi @ original_mw

erosion_attribute = "Erosion" #Name of the Color Attribute to store erosion values
erosions = [] #list of faces with calculated erosions
transparents = [] #list of faces without calculated erosions and therefore transparent
f = open(outfile, "w")
f.write("FaceID, X, Y, Z, Area, Erosion, Volume\n")

#loop through all faces in original_obj
for face in original_obj.data.polygons:

    [Xc, Yc, Zc] = original_mw @ face.center
    if Zc >= Zmin and Zc <= Zmax:
        #write result to output text file
        f.write("%d, %.2e, %.2e, %.2e, %.2e" % (face.index, Xc, Yc, Zc, face.area))
        
    #calculate erosions
    o = matrice @ face.center                         #vector origin at face center
    n = matrice @ (face.center + face.normal) - o     #vector orientation normal to face center
    hit, loc, norm, index = eroded_obj.ray_cast(o, n) #function ray_cast: returns hit (boolean) and loc (point of hit)

    #saves the result in the "erosions" list if erosion is within "erosion_max" and Z is within Zmin-Zmax
    #otherwise append in the "transparents" list
    erosion_append = 0
    if hit:
        erosion = (eroded_mw @ o - eroded_mw @ loc).length
        if erosion <= erosion_max and Zc >= Zmin and Zc <= Zmax:
            erosion_append = 1
    
    if erosion_append:
        erosions.append((face.index, erosion))
        volume = erosion * face.area
        f.write(", %.2e, %.2e\n" % (erosion, volume))
    else:
        transparents.append((face.index))
        if Zc >= Zmin and Zc <= Zmax:
            f.write("\n")
f.close()

#calculate min, max and range of the calculated erosion values
erosion_min = (min([row[1] for row in erosions]))
erosion_max = (max([row[1] for row in erosions]))
erosion_range = erosion_max - erosion_min

#set a new color attribute 
if not original_obj.data.vertex_colors.get(erosion_attribute):
    original_obj.data.vertex_colors.new(name=erosion_attribute)
color_layer = original_obj.data.vertex_colors[erosion_attribute]

#scroll through the list of faces with calculated erosions, and set a corresponding gray color value in the range 0...1
colors = []
for face_index, erosion in erosions:
    face = original_obj.data.polygons[face_index]
    for i in face.loop_indices:
        color = ((erosion - erosion_min) / erosion_range)
        colors.append((color))
        color_layer.data[i].color = (color,color,color,1)

#scroll through the list of faces without calculated erosions, and set them transparent
for face_index in transparents:
    face = original_obj.data.polygons[face_index]
    for i in face.loop_indices:
        color_layer.data[i].color = (0,0,0,0)